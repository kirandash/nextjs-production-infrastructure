# Next.js Workshop - Setting Up Production-Ready Infrastructure for Scalable Apps

## 1 Eslint and prettier (my-first-next-app)

- Eslint: Linting tool for identifying and reporting on patterns found in ECMAScript/JavaScript code. And check for errors etc.
- Prettier: Code formatter that enforces a consistent style by parsing your code and re-printing it with its own rules that take the maximum line length into account, wrapping code when necessary.
- Both these tools will help you to maintain a consistent code style and avoid errors.
- Create a new next project
  - `pnpm dlx create-next-app@latest my-first-next-app --use-pnpm`
  - install with all defaults
  - check eslintrc.json and you should see: `"extends": ["next/core-web-vitals", "next/typescript"]`
  - to run lint: `pnpm run lint`
  - install prettier and make sure prettier and eslint are in sync
    - https://prettier.io/
    - important: how to make sure prettier and eslint rules does not conflict with each other
    - https://github.com/prettier/eslint-config-prettier
    - `pnpm add --save-dev prettier eslint-config-prettier prettier-plugin-tailwindcss`
    - Prettier plugins:
      - Prettier Tailwind plugin
        - https://www.npmjs.com/package/prettier-plugin-tailwindcss
      - Import sort plugins:
        - https://github.com/trivago/prettier-plugin-sort-imports
        - https://github.com/IanVS/prettier-plugin-sort-imports (âœ… Recommended)
          - `pnpm add --save-dev @ianvs/prettier-plugin-sort-imports`

## 2 Project organization (my-first-next-app)

### 2.1 Component File Patterns

- 1. One component per file (Some Developers do this but not recommended)

  - it works well with small components ex: Button, Input etc but not with complex components. With complex component it's possible that the line number will go in 100s ex: 500 lines of code. And then it might make the chunk size bigger.
  - Note that if prop changes, the whole component will re-render. So it's better to split the component into smaller components. So that only the smaller component will re-render.

- 2. Nested Components ðŸš¨ - Anti-Pattern

  - DO NOT USE THIS PATTERN!
  - Drawbacks:
    - If you have a component that has more than 3 levels of nesting, then it's better to move that component to a separate file.
    - Component Definition Inside Component: Each component is defined inside another component, which means they get redefined on every render.
    - State Management Issues: Each nested component has its own state, but they're recreated on every render of their parent, which can lead to unexpected behavior.
    - Poor Reusability: These components can't be used anywhere else in the application since they're scoped inside their parent component.
    - Debugging Difficulty: The component hierarchy becomes harder to understand and debug due to the nested structure.
    - Performance Issues: React hooks (like useState) should not be used in nested component definitions as they can lead to bugs and memory leaks.
    - Next.js will not be able to optimize the nested components as well as the top level components.

- 3. âœ… Recommended: One exported component per file
  - Benefits:
    - One Component Per File: Each component is defined in its own file, making it easier to maintain and test.
    - Clear Dependencies: The import/export structure clearly shows how components depend on each other.
    - Reusability: Components can be easily reused in other parts of the application.
    - Maintainability: Each file has a single responsibility, making the code easier to understand and modify.
    - Better Testing: Components can be tested in isolation more easily.
    - Proper Tree-Shaking: Unused components can be eliminated during the build process.
  - Rules:
  - Don't put too many lines of code in one file
  - Max 200 lines of code per file

### 2.2 Component Folder Structure and how to import them

- Each component may have multiple related files ex:
  - the component itself
  - test file
  - storybook file
  - documentation
  - style file
- How to organize the assets?
  - All files related to a component should be in the same folder.
    - One component per folder
  - Please use relative paths for importing all the assets within the component folder.
- Benefits:
  - Easier to navigate
  - Easier to understand
  - Easier to test
  - Easier to maintain
  - Easier to move the component to another folder

### 2.3 Component Location

- 1. Page specific components
- If a component is only used by one route, then it should be placed in the route folder.
- 2. Shared components
  - If a component is used in multiple routes, then it should be placed in the common components folder.
  - src/app/components
    - shadcn: for all shadcn components
    - bgwebagency-design-system: for all bgwebagency components
- 3. Shared Components across projects:
  - MonoRepo (Turborepo): (âœ… Recommended)
    - components that are used in multiple projects should be moved from app level to packages level
    - apps folder: for all the apps
    - packages folder: for all the packages
      - packages/typescript-config
      - packages/eslint-config
      - packages/ui
        - packages/ui/button
        - packages/ui/card
        - packages/ui/input
        - packages/ui/accordion
        - packages/ui/dialog and so on...
  - npm package:
    - Shared Components can be a single npm package and can be used in multiple projects
    - during local development, we can use the local package by linking it using pnpm
    - This is also ok but I don't use it

### 2.4 Component Naming Conventions

- Not very strict but use either PascalCase or kebab-case
- I use the following naming convention:
  - Standard: `Button.tsx`, `AlertDialog.tsx`, `Checkbox.tsx` etc
    - it uses PascalCase
  - Shadcn: `ui/button.tsx`, `ui/alert-dialog.tsx`, `ui/checkbox.tsx` etc
    - it uses kebab-case
  - bgwebagency: `Button.tsx`, `AlertDialog.tsx`, `Checkbox.tsx` etc
    - it uses PascalCase

## 3. Storybook (my-first-next-app)

- https://storybook.js.org/
- Storybook is a tool for
  - developing UI components and pages in isolation
  - documentation
  - testing
- It also helps collaboration between developers and designers and managers etc.
- It's a good way of demonstrating the component in the best possible way.
- stories.ts:
  - `autodocs`: automatically generate documentation for the component
- use `build-storybook` to build the storybook and you can host it on vercel or any other static site hosting service like s3 etc.
- It's a fantastic tool. Highly recommended.
- Storybook on monorepo might be challenging and more involved.
  - ex: whether to share stories from application or packages or both?
  - we will see in later sessions.

## 4. Unit Testing with Jest (my-first-next-app)

- https://jestjs.io/docs/getting-started
- Installation: `pnpm add --save-dev jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom ts-node @types/jest`
  - `jest-environment-jsdom`: to connect jest with the virtual in memory DOM
  - `@testing-library/jest-dom`: to render our react components in jest dom
  - `@testing-library/react`: to test the react components on jest dom
  - `ts-node`: to run the tests with typescript
  - `@types/jest`: to get the types for jest
- Create a new test file for the component and write the tests for the component
- Initialization:
  - `pnpm create jest@latest`
    - from test environment, select jsdom
  - automatically clear mock calls and instances between every test
    - No

### 4.1 Unit Testing React Server Components

### 4.2 Unit Testing React Client Components

- The tests demonstrate:
  - Component rendering
  - State updates
  - User interactions (clicks and input changes)
  - Conditional rendering
  - Multiple assertions per test
    Proper use of testing-library best practices
- `fireEvent`: to simulate user interactions
  - recommended to use `userEvent` instead of `fireEvent`
  - https://testing-library.com/docs/user-event/intro/
  - `pnpm add --save-dev @testing-library/user-event`

### 4.3 Unit Testing Async React Server Components with Jest with mocking

- Make sure you use `await render`
- Mock the fetch function
- I normally will mock the function during unit test rather than using real API call. But in some use cases ex: when the data is dynamic and changes based on the user input, then we can use the real API call.

### 4.4 Unit Testing Async React Server Components with Jest with isomorphic-fetch

- This is to make the external API call that is shimmed fetch on the server side
- https://www.npmjs.com/package/isomorphic-fetch
- `pnpm add --save-dev isomorphic-fetch`
- jest does not support the fetch API out of the box. So we need to import the isomorphic-fetch module in the test environment.

### 4.5 jest.setup.ts configuration

- This is to import the isomorphic-fetch module in the test environment
- Move the common imports to this file
- This will run before each test

## 5. Unit Testing with Vitest (my-second-next-app)

- Very popular recently
- https://vitest.dev/

### 5.1 Install vitest

- https://www.npmjs.com/package/@vitejs/plugin-react
- `pnpm add -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/jest-dom @testing-library/user-event`
  - vitest is the testing framework
  - @vitejs/plugin-react is the react plugin for vitest
  - jsdom is the virtual dom and faster than testing on browser
  - @testing-library/react is for testing the react components
  - @testing-library/jest-dom is the jest dom is for rendering the react components in the jsdom
  - @testing-library/user-event is the user event library

### 5.2 Vitest Configuration

- https://github.com/vitest-tests/browser-examples/blob/main/examples/react/vitest.config.ts
- add script in package.json
- "test": "vitest run",
- "test:watch": "vitest",
- "test:ui": "vitest --ui"
  - this gives a beautiful UI to see the test results (âœ… Recommended)
  - this also runs in watch mode

### 5.3 Unit Testing RSC

### 5.4 Unit Testing Client Components

- Also it's a good practice to move `@testing-library/jest-dom/vitest` to a setup file to avoid importing it in every test file.

### 5.5 Unit Testing Async RSC

- Mock the fetch function
- Use `afterEach` to clean up the DOM after each test
- The concept is still the same as jest. Only the syntax is different.

## 6. E2E Testing with Cypress (my-first-next-app)

### 6.1 Install Cypress

- E2E testing is where we create a headless browser and allow it to navigate to our site and do user actions like click etc and test
- E2E testing helps us to get a smoke test for our application
- https://www.cypress.io/
- `npx cypress install`: to install cypress on the local machine
- `npx cypress open`: to open the cypress UI
